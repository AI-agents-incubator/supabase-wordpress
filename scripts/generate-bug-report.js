#!/usr/bin/env node

/**
 * Generate Bug Report from Playwright Test Results
 *
 * Reads test-results/results.json and generates:
 * - Markdown bug report (test-results/bug-report-TIMESTAMP.md)
 * - Summary statistics
 * - Failed test details with screenshots/videos
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

// Read results.json
const resultsPath = path.join(projectRoot, 'test-results', 'results.json');

if (!fs.existsSync(resultsPath)) {
  console.error('‚ùå No test results found at:', resultsPath);
  console.error('Run tests first: npm run test:smoke');
  process.exit(1);
}

const results = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));

// Calculate statistics
const stats = {
  total: 0,
  passed: 0,
  failed: 0,
  skipped: 0,
  flaky: 0,
};

const failedTests = [];
const consoleErrors = [];
const networkErrors = [];

// Process test results
if (results.suites) {
  results.suites.forEach(suite => {
    processSuite(suite);
  });
}

function processSuite(suite) {
  if (suite.suites) {
    suite.suites.forEach(s => processSuite(s));
  }

  if (suite.specs) {
    suite.specs.forEach(spec => {
      spec.tests.forEach(test => {
        stats.total++;

        const status = test.results[0]?.status || 'unknown';

        if (status === 'passed') stats.passed++;
        else if (status === 'failed') {
          stats.failed++;

          failedTests.push({
            title: spec.title,
            file: spec.file,
            project: test.projectName || 'unknown',
            error: test.results[0]?.error?.message || 'Unknown error',
            stack: test.results[0]?.error?.stack || '',
            duration: test.results[0]?.duration || 0,
            attachments: test.results[0]?.attachments || [],
          });
        }
        else if (status === 'skipped') stats.skipped++;
        else if (status === 'flaky') stats.flaky++;
      });
    });
  }
}

// Generate timestamp
const now = new Date();
const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);

// Generate bug report
let report = `# üêõ Bug Report - ${now.toLocaleString('ru-RU')}

**Generated:** ${now.toISOString()}
**Test Run:** Supabase Bridge E2E Tests

---

## üìä Summary

- **Total Tests:** ${stats.total}
- **Passed:** ${stats.passed} ‚úÖ
- **Failed:** ${stats.failed} ‚ùå
- **Skipped:** ${stats.skipped} ‚è≠Ô∏è
- **Flaky:** ${stats.flaky} ‚ö†Ô∏è

**Success Rate:** ${stats.total > 0 ? ((stats.passed / stats.total) * 100).toFixed(1) : 0}%

---
`;

// Failed tests section
if (failedTests.length > 0) {
  report += `## ‚ùå Failed Tests (${failedTests.length})\n\n`;

  failedTests.forEach((test, index) => {
    report += `### ${index + 1}. ${test.title}\n\n`;
    report += `**Project:** ${test.project}  \n`;
    report += `**File:** \`${test.file}\`  \n`;
    report += `**Duration:** ${(test.duration / 1000).toFixed(2)}s  \n\n`;

    report += `**Error:**\n\`\`\`\n${test.error}\n\`\`\`\n\n`;

    if (test.stack) {
      report += `**Stack Trace:**\n\`\`\`\n${test.stack.slice(0, 500)}\n\`\`\`\n\n`;
    }

    // Attachments (screenshots, videos)
    if (test.attachments.length > 0) {
      report += `**Attachments:**\n`;
      test.attachments.forEach(att => {
        if (att.name === 'screenshot') {
          report += `- üì∏ Screenshot: \`${att.path}\`\n`;
        } else if (att.name === 'video') {
          report += `- üé• Video: \`${att.path}\`\n`;
        } else if (att.name === 'trace') {
          report += `- üîç Trace: \`${att.path}\`\n`;
        }
      });
      report += '\n';
    }

    report += '---\n\n';
  });
} else {
  report += `## ‚úÖ All Tests Passed!\n\nNo failed tests to report.\n\n---\n\n`;
}

// Console errors section
if (consoleErrors.length > 0) {
  report += `## üñ•Ô∏è Console Errors\n\n`;
  consoleErrors.forEach(err => {
    report += `- **[${err.project}]** ${err.message}\n`;
  });
  report += '\n---\n\n';
}

// Network errors section
if (networkErrors.length > 0) {
  report += `## üåê Network Failures\n\n`;
  networkErrors.forEach(err => {
    report += `- **[${err.project}]** ${err.url} - ${err.error}\n`;
  });
  report += '\n---\n\n';
}

// Recommendations section
if (failedTests.length > 0) {
  report += `## üí° Next Steps\n\n`;
  report += `1. Review failed test details above\n`;
  report += `2. Check screenshots and videos in test-results/\n`;
  report += `3. Fix identified issues\n`;
  report += `4. Re-run tests: \`npm run test:smoke\`\n`;
  report += `5. Verify all tests pass before deployment\n\n`;
}

// Footer
report += `---\n\n`;
report += `**Report generated by:** \`scripts/generate-bug-report.js\`  \n`;
report += `**View HTML report:** \`npx playwright show-report\`  \n`;
report += `**View JSON results:** \`test-results/results.json\`\n`;

// Save report
const reportPath = path.join(projectRoot, 'test-results', `bug-report-${timestamp}.md`);
fs.writeFileSync(reportPath, report, 'utf8');

console.log('');
console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
console.log('üìù Bug Report Generated');
console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
console.log('');
console.log(`üìä Summary: ${stats.passed}/${stats.total} passed (${((stats.passed / stats.total) * 100).toFixed(1)}%)`);
console.log(`üìÑ Report: ${reportPath}`);
console.log('');

if (failedTests.length > 0) {
  console.log(`‚ö†Ô∏è  ${failedTests.length} test(s) failed - review report for details`);
  process.exit(1);
} else {
  console.log('‚úÖ All tests passed!');
  process.exit(0);
}
